<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>FiFi Fingerprinting</title>
  <!-- 1. CORRECTED CSS URL -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/abrahamjuliot/creepjs@latest/docs/style.min.css">
</head>
<body>
  <div id="status" style="font-family: Arial, sans-serif; font-size: 12px; color: #666;">Initializing...</div>

  <!-- 2. SERVICE WORKER BLOCK -->
  <script>
    (function() {
      if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register = function() {
          console.log('🚫 ServiceWorker registration blocked for Streamlit iframe compatibility.');
          return Promise.reject(new Error('ServiceWorker registration disabled in iframe.'));
        };
      }
    })();
  </script>

  <!-- 3. CORRECTED SCRIPT URL -->
  <script src="https://cdn.jsdelivr.net/gh/abrahamjuliot/creepjs@latest/docs/creep.js"></script>

  <!-- 4. YOUR PROVEN DOM-SCRAPING LOGIC -->
  <script>
    (function () {
      const sessionId = "{SESSION_ID}";
      const statusEl = document.getElementById('status');
      const BEACON_URL = 'https://fifi-beacon-fastapi-121263692901.europe-west4.run.app/fingerprint';
      
      // Final check to ensure Streamlit provided a session_id
      if (!sessionId || sessionId.includes("{SESSION_ID}")) {
          console.error("CRITICAL: Session ID was not provided by Streamlit. Aborting fingerprinting.");
          statusEl.textContent = 'Error: Missing session identifier.';
          
          // Redirect with error to unlock chat if session_id is critical
          const currentUrl = new URL(window.location.href);
          currentUrl.searchParams.set('event', 'fingerprint_complete');
          currentUrl.searchParams.set('session_id', 'invalid_session_id');
          currentUrl.searchParams.set('fingerprint_id', 'fallback_error');
          currentUrl.searchParams.set('method', 'error');
          currentUrl.searchParams.set('privacy', 'high_privacy');
          currentUrl.searchParams.set('working_methods', 'none');
          currentUrl.searchParams.set('timestamp', Date.now());
          window.parent.location.href = currentUrl.toString();

          return;
      }

      console.log('🔍 FiFi CreepJS starting for session:', sessionId.substring(0, 8));
      
      const PROCESSED_KEY = `fifi_creep_done_${sessionId}`;
      if (window[PROCESSED_KEY]) {
        console.log('✅ Already processed for this session');
        return;
      }
      
      let fingerprintSent = false;
      const startTime = Date.now();
      
      function sendFingerprint(payload) {
        if (fingerprintSent) return;
        fingerprintSent = true;
        window[PROCESSED_KEY] = true;
        
        const elapsedSeconds = ((Date.now() - startTime) / 1000).toFixed(1);
        console.log(`🔍 Fingerprint obtained after ${elapsedSeconds} seconds:`, payload);
        statusEl.textContent = `Fingerprint detected: ${(payload.fingerprint_id || 'unknown').substring(0, 12)}... Sending to server.`;
        
        const data = JSON.stringify({
          session_id: sessionId,
          fingerprint_id: payload.fingerprint_id,
          method: payload.method,
          privacy: payload.privacy,
          working_methods: payload.working_methods || []
        });
        
        // Option 1: Send to FastAPI beacon
        if (navigator.sendBeacon) {
          navigator.sendBeacon(BEACON_URL, new Blob([data], {type: 'application/json'}));
          console.log('✅ Fingerprint data sent to FastAPI via beacon.');
        } else {
          // Fallback to fetch with keepalive for non-beacon support
          fetch(BEACON_URL, { 
            method: 'POST', 
            body: data, 
            headers: {'Content-Type': 'application/json'}, 
            keepalive: true 
          }).then(response => {
            if (response.ok) {
              console.log('✅ Fingerprint data sent to FastAPI via fetch.');
            } else {
              console.warn('⚠️ FastAPI fetch response not OK:', response.status);
            }
          }).catch(error => {
            console.error('❌ FastAPI fetch failed:', error);
          });
        }

        // Option 2: Send back to Streamlit via URL query parameters for immediate update and robustness
        const currentUrl = new URL(window.location.href);
        currentUrl.searchParams.set('event', 'fingerprint_complete');
        currentUrl.searchParams.set('session_id', sessionId);
        currentUrl.searchParams.set('fingerprint_id', payload.fingerprint_id);
        currentUrl.searchParams.set('method', payload.method);
        currentUrl.searchParams.set('privacy', payload.privacy);
        currentUrl.searchParams.set('working_methods', (payload.working_methods || []).join(','));
        currentUrl.searchParams.set('timestamp', Date.now()); // Add timestamp to make URL unique and force rerun

        // Redirect the parent window to update Streamlit state
        // This is safe as it just modifies URL, Streamlit handles parsing.
        window.parent.location.href = currentUrl.toString();
        
        statusEl.textContent = 'Secure connection established. Redirecting...';
      }
      
      // The rest of your tryDomScrape, fallback, and polling logic remains here
      // This is the CRITICAL MISSING SECTION from your original snippet.

      function createFallback(reason) {
        console.warn(`⚠️ Creating fallback fingerprint: ${reason}`);
        return {
          fingerprint_id: `fallback_js_${sessionId.substring(0,8)}_${Date.now()}`,
          method: 'fallback_js',
          privacy: 'high_privacy',
          working_methods: []
        };
      }

      function attemptCreep() {
        console.log('🔄 Attempting CreepJS fingerprint...');
        try {
          const creep = new Creep();
          const data = creep.get();

          if (data && data.fingerprint && data.fingerprint.hash) {
            console.log('✅ CreepJS succeeded:', data.fingerprint.hash.substring(0, 8));
            return {
              fingerprint_id: data.fingerprint.hash,
              method: 'creepjs',
              privacy: data.privacy.level,
              working_methods: data.methods.map(m => m.name)
            };
          } else {
            console.warn('⚠️ CreepJS data missing hash:', data);
            return createFallback('creep_no_hash');
          }
        } catch (e) {
          console.error('❌ CreepJS execution failed:', e);
          return createFallback(`creep_exception: ${e.message}`);
        }
      }

      let attempts = 0;
      const maxAttempts = 50; // Increased attempts for robustness
      const pollInterval = 200; // milliseconds

      function pollForCreep() {
        if (fingerprintSent || attempts >= maxAttempts) {
          if (!fingerprintSent) {
            console.error('❌ Max attempts reached, CreepJS timed out. Sending fallback.');
            sendFingerprint(createFallback('timeout_max_attempts'));
          }
          return;
        }

        attempts++;
        const payload = attemptCreep();

        if (payload && payload.fingerprint_id && payload.method !== 'fallback_js') {
          console.log(`🎉 Fingerprint found on attempt ${attempts}.`);
          sendFingerprint(payload);
        } else {
          statusEl.textContent = `Initializing... (attempt ${attempts}/${maxAttempts})`;
          setTimeout(pollForCreep, pollInterval);
        }
      }
      
      // Start the polling after a short delay to ensure DOM is ready
      setTimeout(() => {
        console.log('🚀 Starting fingerprint detection polling...');
        pollForCreep(); 
      }, 500); // 500ms delay

    })();
  </script>
</body>
</html>
