<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>FiFi Fingerprinting</title>
  <style>
    body { margin: 0; padding: 10px; font-family: Arial, sans-serif; }
    #status { margin-top: 10px; font-size: 12px; color: #666; }
  </style>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/abrahamjuliot/creepjs@latest/docs/style.min.css">
</head>
<body>
<!-- CreepJS DOM structure -->
<div id="fp-app">
  <fingerprint>
    <div id="fingerprint-data">
      <div class="fingerprint-header-container">
        <div class="fingerprint-header">
          <div class="ellipsis-all">FP ID: Computing...</div>
        </div>
      </div>
    </div>
  </fingerprint>
</div>

<div id="status">Initializing CreepJS...</div>

<!-- Load CreepJS -->
<script src="https://cdn.jsdelivr.net/gh/abrahamjuliot/creepjs@latest/docs/creep.js"></script>

<script>
(function () {
  const sessionId = {SESSION_ID}; // Injected by Python
  const fastapiFingerprintUrl = {FASTAPI_FINGERPRINT_URL}; // Injected by Python
  const fingerprintTimeoutSeconds = {FINGERPRINT_TIMEOUT_SECONDS}; // Injected by Python
  const statusEl = document.getElementById('status');
  
  console.log('🔍 FiFi CreepJS starting for session:', sessionId.substring(0, 8));
  
  const PROCESSED_KEY = `fifi_creep_done_${sessionId}`;
  if (sessionStorage.getItem(PROCESSED_KEY)) {
    console.log('✅ Fingerprint already processed for this session in sessionStorage. Signaling Streamlit ready state.');
    sendPingToStreamlitReadyState('complete'); 
    return;
  }
  
  let fingerprintSent = false;
  const startTime = Date.now();

  function sendPingToStreamlitReadyState(status = 'complete', fpId = '') {
      if (window.fifiPingSent) return; 
      window.fifiPingSent = true;

      const StreamlitAppURL = window.location.origin + window.location.pathname;
      const imageUrl = `${StreamlitAppURL}?event=fingerprint_status_update&session_id=${encodeURIComponent(sessionId)}&status=${encodeURIComponent(status)}&fingerprint_id=${encodeURIComponent(fpId.substring(0,12))}`;
      
      const img = new Image();
      img.src = imageUrl;
      img.style.display = 'none';
      document.body.appendChild(img);
      console.log('✅ Signaled Streamlit readiness via image beacon:', imageUrl);
  }

  async function sendFingerprint(payload) {
    if (fingerprintSent) return;
    fingerprintSent = true;
    sessionStorage.setItem(PROCESSED_KEY, 'true');
    
    const elapsedSeconds = ((Date.now() - startTime) / 1000).toFixed(1);
    console.log(`🔍 Fingerprint obtained after ${elapsedSeconds} seconds. Sending to FastAPI:`, payload);
    statusEl.textContent = `Fingerprint detected: ${(payload.fingerprint_id || 'unknown').substring(0, 12)}...`;

    try {
        const response = await fetch(fastapiFingerprintUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            },
            body: JSON.stringify({
                session_id: sessionId,
                fingerprint_id: payload.fingerprint_id || '',
                method: payload.method || 'unknown',
                privacy: payload.privacy || 'standard',
                working_methods: payload.working_methods || []
            }),
            keepalive: true
        });

        if (!response.ok) {
            console.error(`❌ FastAPI fingerprint endpoint responded with status ${response.status}`);
            statusEl.textContent = `Error sending FP (status ${response.status})`;
        } else {
            console.log('✅ Fingerprint data sent to FastAPI successfully.');
        }
    } catch (e) {
        console.error('❌ Failed to send fingerprint to FastAPI:', e);
        statusEl.textContent = 'Error: Could not send fingerprint to server';
    } finally {
        sendPingToStreamlitReadyState('complete', payload.fingerprint_id || 'fallback');
    }
  }
  
  function tryDomScrape() {
    console.log('🔎 Attempting DOM scrape...');
    
    // Debug: Log all elements with class 'ellipsis-all'
    const allEllipsis = document.querySelectorAll('.ellipsis-all');
    console.log('Found elements with .ellipsis-all:', allEllipsis.length);
    allEllipsis.forEach((el, i) => {
      console.log(`  [${i}] Text: "${el.textContent}"`);
    });
    
    // Try multiple possible selectors for CreepJS fingerprint
    const selectors = [
      '.fingerprint-header .ellipsis-all',
      '#fingerprint-data .ellipsis-all',
      '.visitor-fingerprint .ellipsis-all',
      '.fingerprint',
      '[data-fingerprint]',
      '.fp-hash',
      '#creepjs-fingerprint'
    ];
    
    for (const selector of selectors) {
      const elements = document.querySelectorAll(selector);
      console.log(`Selector "${selector}" found ${elements.length} elements`);
      
      for (const el of elements) {
        const text = el.textContent || el.getAttribute('data-fingerprint') || '';
        console.log(`  Checking text: "${text}"`);
        
        // Look for hex patterns that could be fingerprints
        const hexMatches = text.match(/[a-f0-9]{32,64}/gi);
        if (hexMatches) {
          for (const match of hexMatches) {
            if (match.length >= 32) {
              console.log('✅ Found potential fingerprint:', match);
              sendFingerprint({
                fingerprint_id: match,
                method: 'creepjs_dom',
                privacy: 'standard',
                working_methods: ['creepjs']
              });
              return true;
            }
          }
        }
      }
    }
    
    // Also check if CreepJS has exposed any global variables
    if (window.creepjs) {
      console.log('Found window.creepjs:', window.creepjs);
    }
    
    // Check for CreepJS fingerprint in sessionStorage or localStorage
    for (const storage of [sessionStorage, localStorage]) {
      for (let i = 0; i < storage.length; i++) {
        const key = storage.key(i);
        if (key && key.toLowerCase().includes('creep')) {
          const value = storage.getItem(key);
          console.log(`Found storage key "${key}":`, value);
          if (value && /[a-f0-9]{32,64}/i.test(value)) {
            console.log('✅ Found fingerprint in storage');
            sendFingerprint({
              fingerprint_id: value,
              method: 'creepjs_storage',
              privacy: 'standard',
              working_methods: ['creepjs']
            });
            return true;
          }
        }
      }
    }
    
    return false;
  }
  
  function createFallback(reason) {
    console.warn('⚠️ Using fallback fingerprint, reason:', reason);
    statusEl.textContent = 'Using fallback fingerprint (' + reason + ')';
    
    const parts = [];
    parts.push(navigator.userAgent || 'unknown');
    parts.push(`${screen.width}x${screen.height}x${screen.colorDepth}`);
    parts.push(Intl.DateTimeFormat().resolvedOptions().timeZone || 'UTC');
    parts.push(navigator.language || 'en');
    parts.push((navigator.languages || []).join(','));
    parts.push(navigator.platform || 'unknown');
    parts.push(String(navigator.hardwareConcurrency || 0));
    parts.push(String(navigator.deviceMemory || 0));
    
    try {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      ctx.font = '14px Arial';
      ctx.fillText('fifi-fp', 2, 15);
      parts.push(canvas.toDataURL().slice(-50));
    } catch {
      parts.push('canvas_blocked');
    }
    
    const combined = parts.join('|');
    let hash = 0;
    for (let i = 0; i < combined.length; i++) {
      hash = ((hash << 5) - hash) + combined.charCodeAt(i);
      hash = hash & hash;
    }
    
    const fallbackId = `fallback_${Math.abs(hash).toString(16)}_${Date.now().toString(36)}`;
    
    sendFingerprint({
      fingerprint_id: fallbackId,
      fuzzy: '',
      method: 'fallback',
      privacy: 'high_privacy',
      working_methods: []
    });
  }
  
  // Try to intercept CreepJS when it's ready
  let creepjsCheckInterval = setInterval(() => {
    // Check if CreepJS has finished by looking for results
    const fpElements = document.querySelectorAll('.fingerprint, .visitor-fingerprint, [class*="fingerprint"]');
    let foundValidFp = false;
    
    for (const el of fpElements) {
      const text = el.textContent || '';
      if (text.includes('Computing') || text.includes('loading')) {
        console.log('CreepJS still computing...');
        return; // Still loading
      }
      
      // Look for hex patterns
      const hexMatch = text.match(/[a-f0-9]{32,64}/i);
      if (hexMatch) {
        console.log('✅ Found CreepJS fingerprint via interval check:', hexMatch[0]);
        sendFingerprint({
          fingerprint_id: hexMatch[0],
          method: 'creepjs_interval',
          privacy: 'standard',
          working_methods: ['creepjs']
        });
        foundValidFp = true;
        clearInterval(creepjsCheckInterval);
        break;
      }
    }
    
    if (!foundValidFp) {
      console.log('CreepJS check - no valid fingerprint found yet');
    }
  }, 500);
  
  // Clear interval after timeout
  setTimeout(() => {
    clearInterval(creepjsCheckInterval);
  }, fingerprintTimeoutSeconds * 1000);
  
  let attempts = 0;
  const maxAttempts = 30; 
  
  function attemptFingerprint() {
    attempts++;
    const elapsedSeconds = ((Date.now() - startTime) / 1000).toFixed(1);
    console.log(`Attempt ${attempts}/${maxAttempts} at ${elapsedSeconds}s`);
    
    if (tryDomScrape()) {
      clearInterval(creepjsCheckInterval);
      return;
    }
    
    if (attempts < maxAttempts) {
      const delay = attempts < 5 ? 200 : attempts < 15 ? 300 : 500;
      setTimeout(attemptFingerprint, delay);
    } else {
      clearInterval(creepjsCheckInterval);
      createFallback('max_attempts_reached');
    }
  }
  
  setTimeout(() => {
    console.log('🚀 Starting fingerprint detection...');
    attemptFingerprint();
  }, 2000); // Give CreepJS more time to initialize
  
  setTimeout(() => {
    if (!fingerprintSent) {
      console.error(`⏰ Absolute timeout reached after ${fingerprintTimeoutSeconds} seconds`);
      clearInterval(creepjsCheckInterval);
      createFallback(`absolute_timeout_${fingerprintTimeoutSeconds}s`);
    }
  }, fingerprintTimeoutSeconds * 1000);
})();
</script>
</body>
</html>
