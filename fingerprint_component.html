<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>FiFi Fingerprinting</title>
  <style>
    /* Minimal styling to keep the component hidden and unobtrusive */
    body { margin: 0; overflow: hidden; }
    #fp-app { display: none; } /* Hide the CreepJS UI as it's not for the end-user */
    #status { position: absolute; top: 5px; left: 5px; font-family: Arial, sans-serif; font-size: 10px; color: #aaa; }
  </style>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/abrahamjuliot/creepjs@latest/docs/style.min.css">
</head>
<body>

<!-- Required DOM structure for CreepJS to inject its data into -->
<div id="fp-app">
  <fingerprint>
    <div id="fingerprint-data">
      <div class="fingerprint-header-container">
        <div class="fingerprint-header">
          <div class="ellipsis-all">FP ID: Computing...</div>
        </div>
      </div>
    </div>
  </fingerprint>
</div>

<div id="status">Initializing...</div>

<!-- Load the CreepJS library -->
<script src="https://cdn.jsdelivr.net/gh/abrahamjuliot/creepjs@latest/docs/creep.js"></script>

<!-- Main logic using MutationObserver for speed and reliability -->
<script>
(function () {
  // This placeholder is replaced by Python with the raw session ID string
  const sessionId = "{SESSION_ID}";
  const statusEl = document.getElementById('status');
  
  // --- Robustness Check ---
  if (!sessionId || sessionId.includes("{SESSION_ID}")) {
      console.error("CRITICAL: Session ID was not injected correctly by Python. Cannot proceed.");
      statusEl.textContent = 'Error: Missing session ID.';
      redirectToStreamlit('error_js_no_session');
      return;
  }

  console.log('üîç FiFi CreepJS starting for session:', sessionId.substring(0, 8));

  // --- State Management ---
  const PROCESSED_KEY = `fifi_creep_done_${sessionId}`;
  if (window[PROCESSED_KEY]) {
    console.log('‚úÖ Already processed for this session. Exiting.');
    return;
  }
  let fingerprintSent = false;

  // --- Centralized Redirect Function ---
  function redirectToStreamlit(reason, payload = {}) {
      if (fingerprintSent) return;
      fingerprintSent = true;
      window[PROCESSED_KEY] = true;
      
      console.log(`üöÄ Redirecting to Streamlit. Reason: ${reason}`);
      
      let baseUrl = window.location.origin + window.location.pathname;
      try {
        if (window.parent && window.parent !== window && window.parent.location.href) {
          const parentUrl = new URL(window.parent.location.href);
          baseUrl = parentUrl.origin + parentUrl.pathname;
        }
      } catch (e) { /* Fallback to self origin if parent is inaccessible */ }

      const url = new URL(baseUrl);
      url.searchParams.set('event', 'fingerprint_complete');
      url.searchParams.set('session_id', sessionId);
      url.searchParams.set('fingerprint_id', payload.fingerprint_id || `fallback_js_${sessionId.substring(0,8)}_${Date.now().toString(36)}`);
      url.searchParams.set('method', payload.method || reason);
      url.searchParams.set('privacy', payload.privacy || 'high_privacy');
      url.searchParams.set('working_methods', (payload.working_methods || []).join(','));
      url.searchParams.set('timestamp', Date.now());

      if (window.parent && window.parent !== window) {
        window.parent.location.replace(url.toString());
      } else {
        window.location.replace(url.toString());
      }
  }
  
  // Helper to validate the scraped hash format
  function asHex(s) {
    return (typeof s === 'string' && /^[a-f0-9]{32,64}$/i.test(s)) ? s : null;
  }
  
  // --- The Core Logic: Using MutationObserver for instant reaction ---
  const targetNode = document.querySelector('#fingerprint-data .fingerprint-header .ellipsis-all');

  if (!targetNode) {
    console.error("CRITICAL: CreepJS target DOM node not found. Check the HTML structure.");
    redirectToStreamlit('fallback_dom_error');
    return;
  }

  // This function is triggered *by the browser* the moment the fingerprint ID appears
  const observerCallback = function(mutationsList, observer) {
    for(const mutation of mutationsList) {
        const fpText = targetNode.textContent || '';
        const fpMatch = fpText.match(/FP\s*ID:\s*([a-f0-9]{32,64})/i);
        const stableId = fpMatch ? asHex(fpMatch[1]) : null;

        if (stableId) {
          console.log('‚úÖ Fingerprint detected by MutationObserver:', stableId.substring(0, 8));
          // Once we have a valid ID, send it and immediately stop watching
          redirectToStreamlit('creepjs_observer', {
            fingerprint_id: stableId,
            method: 'creepjs_observer',
            privacy: 'standard', // CreepJS success implies standard privacy level
            working_methods: ['creepjs']
          });
          observer.disconnect(); // Crucial: Stop observing to prevent future triggers
          return;
        }
    }
  };

  // Create and start the observer to watch for changes
  const observer = new MutationObserver(observerCallback);
  observer.observe(targetNode, { childList: true, subtree: true });
  statusEl.textContent = 'Waiting for fingerprint...';
  console.log('üëÄ MutationObserver is now watching for CreepJS to complete...');

  // --- Safety Net: Absolute Timeout ---
  // A fallback in case CreepJS crashes or the observer never fires for some reason.
  setTimeout(() => {
    if (!fingerprintSent) {
      console.error('‚è∞ Absolute timeout reached (7s). CreepJS likely failed. Sending fallback.');
      observer.disconnect(); // Stop observing
      redirectToStreamlit('fallback_absolute_timeout');
    }
  }, 7000); // A generous but reasonable 7-second maximum wait time.

})();
</script>
</body>
</html>
