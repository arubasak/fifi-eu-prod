<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>FiFi Fingerprinting Component</title>
  <style>
    body {
      margin: 0;
      padding: 20px; /* Increased padding */
      font-family: Arial, sans-serif;
      background-color: #f0f2f6; /* Streamlit's default background */
      color: #333;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      min-height: 100%; /* Fill component's iframe height */
      box-sizing: border-box; /* Include padding in height */
    }
    #fp-app {
      border: 1px solid #ccc;
      padding: 15px;
      border-radius: 8px;
      background-color: #fff;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      width: 90%;
      max-width: 400px; /* Slightly smaller for aesthetics */
      text-align: center;
      margin-bottom: 20px;
    }
    #status {
      margin-top: 15px;
      font-size: 14px;
      color: #333;
      font-weight: bold;
    }
    .progress-bar-container {
      width: 90%;
      max-width: 400px;
      background-color: #e0e0e0;
      border-radius: 5px;
      height: 10px;
      overflow: hidden;
      margin-top: 10px;
    }
    .progress-bar {
      height: 100%;
      width: 0%;
      background-color: #ff6b6b; /* FiFi red color */
      border-radius: 5px;
      transition: width 0.5s ease-in-out;
    }
    /* Hide CreepJS's verbose logs for cleaner display to user */
    .fingerprint-header-container { display: none; }
    .fuzzy-fp { display: none; }
    .time { display: none; }
  </style>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/abrahamjuliot/creepjs@latest/docs/style.min.css">
</head>
<body>

<div id="fp-app">
  <fingerprint>
    <div id="fingerprint-data">
      <div class="fingerprint-header-container">
        <div class="fingerprint-header">
          <div class="ellipsis-all">FP ID: Computing...</div>
          <div id="fuzzy-fingerprint">
            <div class="ellipsis-all fuzzy-fp">Fuzzy:
              <span>0000000000000000000000000000000000000000000000000000000000000000</span>
            </div>
          </div>
          <div><span class="time">0 ms</span></div>
        </div>
      </div>
    </div>
  </fingerprint>
</div>

<div id="status">Initializing CreepJS...</div>
<div class="progress-bar-container">
  <div id="inner-progress-bar" class="progress-bar"></div>
</div>

<script>
(function() {
  console.log('üö´ Blocking ServiceWorker registration...');
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register = function() {
      console.log('üö´ ServiceWorker registration blocked for Streamlit iframe compatibility');
      return Promise.reject(new Error('ServiceWorker registration disabled in iframe'));
    };
    Object.defineProperty(navigator.serviceWorker, 'controller', {
      get: function() { return null; }
    });
  }
  console.log('‚úÖ ServiceWorker blocking initialized');
})();
</script>

<script src="https://cdn.jsdelivr.net/gh/abrahamjuliot/creepjs@latest/docs/creep.js"></script>

<script>
document.addEventListener('DOMContentLoaded', function() {
  console.log('üöÄ DOMContentLoaded fired. Starting main script block in iframe...');

  const sessionId = "{SESSION_ID}"; 
  const statusEl = document.getElementById('status');
  const progressBar = document.getElementById('inner-progress-bar');
  const BEACON_URL = 'https://fifi-beacon-fastapi-121263692901.europe-west4.run.app/fingerprint';
  // MODIFIED: Increase client-side timeout to accommodate longer polling
  const FINGERPRINT_SCRAPE_TIMEOUT_SECONDS = 30; // Max time for JS to scrape FP

  // --- Streamlit Callback Function (exposed by st_javascript) ---
  function signalStreamlitCompletion(success, fingerprintData) {
      console.log('‚ö° Signaling Streamlit completion:', success, fingerprintData);
      try {
          if (window.parent && window.parent.streamlit_javascript_callback) {
              window.parent.streamlit_javascript_callback({
                  completed: true,
                  success: success,
                  fingerprint_id: fingerprintData.fingerprint_id,
                  method: fingerprintData.method,
                  privacy: fingerprintData.privacy,
                  working_methods: fingerprintData.working_methods
              });
              console.log('‚úÖ Streamlit callback invoked.');
          } else {
              console.error('‚ùå Streamlit callback not found. Could not signal completion.');
              sendDataViaQuery(fingerprintData); // Fallback to URL redirect
          }
      } catch (e) {
          console.error('‚ùå Error invoking Streamlit callback:', e);
          sendDataViaQuery(fingerprintData); // Fallback to URL redirect
      }
  }

  // --- Fallback if Streamlit callback fails (sends data via URL parameters) ---
  function sendDataViaQuery(fingerprintData) {
      console.warn('‚ö†Ô∏è Attempting to signal completion via URL query parameters (fallback).');
      const queryParams = new URLSearchParams();
      queryParams.set('event', 'fingerprint_complete_fallback'); 
      queryParams.set('session_id', sessionId);
      queryParams.set('fingerprint_id', fingerprintData.fingerprint_id);
      queryParams.set('method', fingerprintData.method);
      queryParams.set('privacy', fingerprintData.privacy);
      queryParams.set('working_methods', fingerprintData.working_methods.join(','));
      
      const targetUrl = window.location.origin + window.location.pathname + '?' + queryParams.toString();
      console.log('Attempting redirect with query params:', targetUrl);
      window.parent.location.replace(targetUrl); 
  }


  // --- CRITICAL SESSION ID VALIDATION ---
  if (!sessionId || sessionId.includes("{SESSION_ID}") || sessionId.length < 5) {
      console.error("CRITICAL: Session ID was not provided by Streamlit or is a placeholder/too short. Aborting fingerprinting.");
      statusEl.textContent = 'Error: Missing session identifier. Cannot secure session.';
      signalStreamlitCompletion(false, { fingerprint_id: 'no_session_id', method: 'error', privacy: 'unknown', working_methods: [] });
      return; 
  }

  console.log('üîç FiFi CreepJS starting for session:', sessionId.substring(0, 8));
  
  if (window.fifiFingerprintSent) {
    console.log('‚úÖ Fingerprint already sent for this page load. Skipping duplicate.');
    return;
  }
  window.fifiFingerprintSent = true; 
  
  let fingerprintFound = false; 
  let fingerprintBeaconSent = false; 
  const initialClientStartTime = Date.now(); 

  function updateProgressBar(progress) {
    progressBar.style.width = `${progress * 100}%`;
  }

  // --- Sends FP to Beacon and then signals Streamlit ---
  async function sendFingerprintAndSignal(payload) {
    if (fingerprintBeaconSent) return; 
    fingerprintBeaconSent = true; 
    
    const elapsedSeconds = ((Date.now() - initialClientStartTime) / 1000).toFixed(1);
    console.log(`‚úÖ Fingerprint obtained after ${elapsedSeconds}s:`, payload.fingerprint_id);
    statusEl.textContent = `Session secured! ID: ${(payload.fingerprint_id || 'unknown').substring(0, 12)}...`;
    updateProgressBar(1.0); 

    const data = JSON.stringify({
      session_id: sessionId,
      fingerprint_id: payload.fingerprint_id,
      method: payload.method,
      privacy: payload.privacy || 'standard', 
      working_methods: payload.working_methods || [],
      timestamp: new Date().toISOString()
    });
    
    try {
        if (navigator.sendBeacon) {
            const sent = navigator.sendBeacon(BEACON_URL, new Blob([data], {type: 'application/json'}));
            if (sent) {
                console.log('‚úÖ Fingerprint data queued for sending via beacon successfully.');
            } else {
                console.warn('‚ùå navigator.sendBeacon failed. This is not critical, Fetch fallback is not needed as Streamlit will be signaled.');
            }
        } else {
            console.warn('‚ö†Ô∏è navigator.sendBeacon not supported. Not using fetch fallback as Streamlit will be signaled.');
        }
    } catch (e) {
        console.error('‚ùå Error sending to Beacon FastAPI:', e);
    }
    
    signalStreamlitCompletion(true, payload);
  }
  
  function tryDomScrape() {
    const header = document.querySelector('#fingerprint-data .fingerprint-header .ellipsis-all');
    const fuzzyEl = document.querySelector('#fuzzy-fingerprint .fuzzy-fp');
    
    if (!header || !fuzzyEl) {
      console.warn('‚ö†Ô∏è Expected CreepJS output DOM elements not found in iframe for scraping.');
      return false; 
    }
    
    const fpText = header.textContent || '';
    const fuzzyTxt = fuzzyEl.textContent || '';
    
    const fpMatch = fpText.match(/FP\s*ID:\s*([a-f0-9]{32,64})/i);
    const fuzzyMatch = fuzzyTxt.match(/Fuzzy:\s*([a-f0-9]{32,64})/i);
    
    const fpId = fpMatch ? fpMatch[1] : null;
    const fuzzy = fuzzyMatch ? fuzzyMatch[1] : null;
    
    if (fpId && fpId !== 'Computing...' && /^[a-f0-9]{32,64}$/i.test(fpId)) {
      console.log('‚úÖ Found fingerprint via DOM scrape:', fpId);
      fingerprintFound = true; 
      sendFingerprintAndSignal({
        fingerprint_id: fpId,
        fuzzy: fuzzy || '',
        method: 'creepjs_dom', 
        privacy: 'standard', 
        working_methods: ['creepjs_dom_scrape']
      });
      return true; 
    }
    
    return false; 
  }
  
  let attempts = 0;
  const maxAttempts = FINGERPRINT_SCRAPE_TIMEOUT_SECONDS / 5; // Adjust max attempts based on new delay
  
  function attemptFingerprint() {
    attempts++;
    
    if (fingerprintFound) { 
        return;
    }

    if (Date.now() - initialClientStartTime > FINGERPRINT_SCRAPE_TIMEOUT_SECONDS * 1000) {
        console.error(`‚ùå Client-side scraping timed out after ${FINGERPRINT_SCRAPE_TIMEOUT_SECONDS}s.`);
        statusEl.textContent = 'Fingerprinting failed (timed out). Falling back.';
        updateProgressBar(1.0); 
        sendFingerprintAndSignal({
            fingerprint_id: `fallback_dom_timeout_${sessionId.substring(0,8)}_${Date.now().toString(36)}`,
            fuzzy: '',
            method: 'creepjs_dom_timeout_fallback',
            privacy: 'high_privacy',
            working_methods: []
        });
        return;
    }

    if (tryDomScrape()) {
      return; 
    }
    
    if (attempts < maxAttempts) {
      const delay = 5000; // MODIFIED: Fixed 5-second polling interval
      setTimeout(attemptFingerprint, delay);
    } else {
      console.error(`‚ùå Max attempts (${maxAttempts}) reached for DOM scraping. Fingerprint not found in DOM.`);
      statusEl.textContent = 'Fingerprinting failed (DOM not updated or elements missing). Falling back.';
      updateProgressBar(1.0); 
      sendFingerprintAndSignal({
          fingerprint_id: `fallback_dom_max_attempts_${sessionId.substring(0,8)}_${Date.now().toString(36)}`, // Unique ID for this fallback
          fuzzy: '',
          method: 'creepjs_dom_max_attempts_fallback',
          privacy: 'high_privacy',
          working_methods: []
      });
    }
    updateProgressBar(Math.min(attempts / maxAttempts, (Date.now() - initialClientStartTime) / (FINGERPRINT_SCRAPE_TIMEOUT_SECONDS * 1000)));
  }
  
  setTimeout(() => {
    console.log('üöÄ Starting fingerprint detection (DOM polling)...');
    statusEl.textContent = 'Checking device characteristics...';
    attemptFingerprint();
  }, 2000); 
});
</script>
</body>
</html>
