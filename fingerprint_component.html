<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>FiFi Fingerprinting</title>
  <style>
    body { margin: 0; padding: 10px; font-family: Arial, sans-serif; }
    #status { margin-top: 10px; font-size: 12px; color: #666; }
  </style>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/abrahamjuliot/creepjs@latest/docs/style.min.css">
</head>
<body>
<!-- CreepJS DOM structure -->
<div id="fp-app">
  <fingerprint>
    <div id="fingerprint-data">
      <div class="fingerprint-header-container">
        <div class="fingerprint-header">
          <div class="ellipsis-all">FP ID: Computing...</div>
          <div id="fuzzy-fingerprint">
            <div class="ellipsis-all fuzzy-fp">Fuzzy:
              <span class="blurred">0000000000000000000000000000000000000000000000000000000000000000</span>
            </div>
          </div>
          <div><span class="time">0 ms</span></div>
        </div>
      </div>
    </div>
  </fingerprint>
</div>

<div id="status">Initializing CreepJS... Please wait up to 20 seconds...</div>

<!-- Load CreepJS -->
<script src="https://cdn.jsdelivr.net/gh/abrahamjuliot/creepjs@latest/docs/creep.js"></script>

<script>
(function () {
  const sessionId = "{SESSION_ID}";
  const statusEl = document.getElementById('status');
  
  console.log('üîç FiFi CreepJS starting for session:', sessionId.substring(0, 8));
  
  // Check if already processed
  const PROCESSED_KEY = `fifi_creep_done_${sessionId}`;
  if (window[PROCESSED_KEY]) {
    console.log('‚úÖ Already processed for this session');
    return;
  }
  
  let fingerprintSent = false;
  const startTime = Date.now();
  
  function sendFingerprint(payload) {
    if (fingerprintSent) return;
    fingerprintSent = true;
    window[PROCESSED_KEY] = true;
    
    const elapsedSeconds = ((Date.now() - startTime) / 1000).toFixed(1);
    console.log(`üîç Fingerprint obtained after ${elapsedSeconds} seconds:`, payload);
    statusEl.textContent = `Fingerprint detected after ${elapsedSeconds}s: ${(payload.fingerprint_id || 'unknown').substring(0, 12)}...`;
    
    // Perform redirect to send data to Python
    setTimeout(() => {
      try {
        // Get the parent window URL if in iframe, otherwise use current
        let baseUrl = window.location.origin + window.location.pathname;
        
        // Try to use parent URL if accessible
        try {
          if (window.parent && window.parent !== window && window.parent.location.href) {
            const parentUrl = new URL(window.parent.location.href);
            baseUrl = parentUrl.origin + parentUrl.pathname;
            console.log('Using parent URL:', baseUrl);
          }
        } catch (e) {
          console.log('Using current URL (parent not accessible):', baseUrl);
        }
        
        const url = `${baseUrl}?event=fingerprint_complete`
          + `&session_id=${encodeURIComponent(sessionId)}`
          + `&fingerprint_id=${encodeURIComponent(payload.fingerprint_id || '')}`
          + `&method=${encodeURIComponent(payload.method || '')}`
          + `&privacy=${encodeURIComponent(payload.privacy || '')}`
          + `&fuzzy=${encodeURIComponent(payload.fuzzy || '')}`
          + `&working_methods=${encodeURIComponent((payload.working_methods || []).join(','))}`
          + `&timestamp=${Date.now()}`;
        
        console.log('üîç Redirecting to:', url);
        statusEl.textContent = 'Sending fingerprint to server...';
        
        // Use parent location if available, otherwise current window
        if (window.parent && window.parent !== window) {
          try {
            window.parent.location.href = url;
          } catch (e) {
            window.location.href = url;
          }
        } else {
          window.location.href = url;
        }
        
      } catch (e) {
        console.error('‚ùå Redirect failed:', e);
        statusEl.textContent = 'Error: Could not send fingerprint to server';
      }
    }, 500); // Small delay to ensure status update is visible
  }
  
  function asHex(s, min = 32, max = 64) {
    return (typeof s === 'string' && new RegExp(`^[a-f0-9]{${min},${max}}$`, 'i').test(s)) ? s : null;
  }
  
  // DOM scraping function
  function tryDomScrape() {
    const header = document.querySelector('#fingerprint-data .fingerprint-header .ellipsis-all');
    const fuzzyEl = document.querySelector('#fuzzy-fingerprint .fuzzy-fp');
    
    if (!header) {
      console.log('‚ùå Header element not found');
      return false;
    }
    
    const fpText = header.textContent || '';
    const fuzzyTxt = fuzzyEl?.textContent || '';
    
    // Only log when content changes
    if (fpText !== 'FP ID: Computing...') {
      console.log('üìù Header text:', fpText);
    }
    
    const fpMatch = fpText.match(/FP\s*ID:\s*([a-f0-9]{32,64})/i);
    const fuzzyMatch = fuzzyTxt.match(/Fuzzy:\s*([a-f0-9]{32,64})/i);
    
    const stable = fpMatch ? asHex(fpMatch[1], 32, 64) : null;
    const fuzzy = fuzzyMatch ? asHex(fuzzyMatch[1], 32, 64) : null;
    
    if (stable && stable !== 'Computing...') {
      console.log('‚úÖ Found fingerprint via DOM scrape:', stable);
      sendFingerprint({
        fingerprint_id: stable,
        fuzzy: fuzzy || '',
        method: 'creepjs_dom',
        privacy: 'standard',
        working_methods: ['creepjs']
      });
      return true;
    }
    
    return false;
  }
  
  // Fallback fingerprint
  function createFallback(reason) {
    console.warn('‚ö†Ô∏è Using fallback fingerprint, reason:', reason);
    statusEl.textContent = 'Using fallback fingerprint (' + reason + ')';
    
    const parts = [];
    parts.push(navigator.userAgent || 'unknown');
    parts.push(`${screen.width}x${screen.height}x${screen.colorDepth}`);
    parts.push(Intl.DateTimeFormat().resolvedOptions().timeZone || 'UTC');
    parts.push(navigator.language || 'en');
    parts.push((navigator.languages || []).join(','));
    parts.push(navigator.platform || 'unknown');
    parts.push(String(navigator.hardwareConcurrency || 0));
    parts.push(String(navigator.deviceMemory || 0));
    
    try {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      ctx.font = '14px Arial';
      ctx.fillText('fifi-fp', 2, 15);
      parts.push(canvas.toDataURL().slice(-50));
    } catch {
      parts.push('canvas_blocked');
    }
    
    const combined = parts.join('|');
    let hash = 0;
    for (let i = 0; i < combined.length; i++) {
      hash = ((hash << 5) - hash) + combined.charCodeAt(i);
      hash = hash & hash;
    }
    
    const fallbackId = `fallback_${Math.abs(hash).toString(16)}_${Date.now().toString(36)}`;
    
    sendFingerprint({
      fingerprint_id: fallbackId,
      fuzzy: '',
      method: 'fallback',
      privacy: 'high_privacy',
      working_methods: []
    });
  }
  
  // Start detection with adjusted timing
  let attempts = 0;
  const maxAttempts = 50; // Increased from 30 to 50
  
  function attemptFingerprint() {
    attempts++;
    const elapsedSeconds = ((Date.now() - startTime) / 1000).toFixed(1);
    statusEl.textContent = `Detecting fingerprint... (attempt ${attempts}/${maxAttempts}, ${elapsedSeconds}s elapsed)`;
    
    if (tryDomScrape()) {
      return;
    }
    
    if (attempts < maxAttempts) {
      // Slower attempts after the first 10 to give CreepJS more time
      const delay = attempts < 10 ? 300 : 500;
      setTimeout(attemptFingerprint, delay);
    } else {
      createFallback('max_attempts_reached');
    }
  }
  
  // Start after longer delay to ensure CreepJS loads (increased from 2s to 3s)
  setTimeout(() => {
    console.log('üöÄ Starting fingerprint detection...');
    attemptFingerprint();
  }, 3000);
  
  // Extended absolute timeout (increased from 15s to 30s)
  setTimeout(() => {
    if (!fingerprintSent) {
      console.error('‚è∞ Absolute timeout reached after 30 seconds');
      createFallback('absolute_timeout_30s');
    }
  }, 30000);
})();
</script>
</body>
</html>
