<!DOCTYPE html>
<html>
<head>
    <style>
        body { margin: 0; padding: 0; }
        #creep { display: none; } /* Hide CreepJS UI elements */
    </style>
</head>
<body>
    <div id="creep"></div> <!-- CreepJS needs this container -->
    
<script>
(function() {
    try {
        const sessionId = "{SESSION_ID}"; 
        
        console.log('🔍 FiFi Fingerprinting (CreepJS): Starting for session', sessionId.substring(0, 8));
        
        // Prevent multiple executions
        if (window.fifi_fp_executed_for_session === sessionId) {
            console.log('🔍 FiFi Fingerprinting: Already executed for this session instance.');
            return;
        }
        window.fifi_fp_executed_for_session = sessionId;

        // Load CreepJS from CDN
        const script = document.createElement('script');
        script.src = 'https://cdn.jsdelivr.net/gh/abrahamjuliot/creepjs@latest/docs/creep.js';
        
        script.onload = function() {
            console.log('🔍 CreepJS library loaded successfully');
            
            // CreepJS automatically starts when loaded, we need to wait for it to complete
            // Check for completion by monitoring DOM changes or using intervals
            let attempts = 0;
            const maxAttempts = 50; // 25 seconds max wait
            
            const checkCreepCompletion = setInterval(function() {
                attempts++;
                
                try {
                    // Check if CreepJS has populated the DOM with results
                    const creepContainer = document.getElementById('creep');
                    
                    // Look for CreepJS fingerprint data in various ways
                    let fingerprintData = null;
                    let workingMethods = [];
                    let privacyScore = 0;
                    
                    // Method 1: Check if global creep object exists
                    if (typeof window.creep !== 'undefined') {
                        console.log('🔍 CreepJS global object found');
                        fingerprintData = window.creep;
                    }
                    
                    // Method 2: Check if CreepJS populated DOM elements
                    else if (creepContainer && creepContainer.innerHTML.length > 100) {
                        console.log('🔍 CreepJS DOM populated, extracting data');
                        
                        // Extract fingerprint components from DOM
                        const components = [];
                        
                        // Look for common CreepJS data patterns in DOM
                        const dataElements = creepContainer.querySelectorAll('[data-*], .hash, .lies, .trash');
                        dataElements.forEach(element => {
                            if (element.textContent && element.textContent.trim().length > 5) {
                                components.push(element.textContent.trim());
                                workingMethods.push(element.className || 'dom_element');
                            }
                        });
                        
                        // Look for hash values specifically
                        const hashElements = creepContainer.querySelectorAll('.hash, [class*="hash"]');
                        hashElements.forEach(element => {
                            if (element.textContent && element.textContent.length > 10) {
                                components.push(element.textContent);
                                workingMethods.push('hash_element');
                            }
                        });
                        
                        if (components.length > 0) {
                            fingerprintData = components.join('|');
                        }
                    }
                    
                    // Method 3: Check for specific CreepJS completion indicators
                    else if (window.caniuse || window.creepWorker || document.querySelector('.creep-browser')) {
                        console.log('🔍 CreepJS indicators found, using basic detection');
                        
                        // Collect what we can from CreepJS environment
                        const basicComponents = [];
                        
                        if (window.caniuse) {
                            basicComponents.push(JSON.stringify(window.caniuse).substring(0, 200));
                            workingMethods.push('caniuse');
                        }
                        
                        // Get any visible hash or fingerprint values from the page
                        const allText = document.body.textContent || '';
                        const hashMatches = allText.match(/[a-f0-9]{16,}/g); // Look for hex hashes
                        if (hashMatches && hashMatches.length > 0) {
                            basicComponents.push(...hashMatches.slice(0, 5)); // Take first 5 hashes
                            workingMethods.push('extracted_hashes');
                        }
                        
                        if (basicComponents.length > 0) {
                            fingerprintData = basicComponents.join('|');
                        }
                    }
                    
                    // If we have fingerprint data, process it
                    if (fingerprintData) {
                        clearInterval(checkCreepCompletion);
                        
                        // Generate fingerprint ID
                        const fingerprintId = 'creepjs_' + hashString(fingerprintData.toString());
                        
                        // Analyze privacy level based on working methods and content
                        let privacy = 'standard';
                        if (workingMethods.length < 3) {
                            privacy = 'high_privacy'; // Few working methods = high privacy
                        } else if (workingMethods.length < 6) {
                            privacy = 'medium_privacy';
                        }
                        
                        // Check for privacy indicators in the content
                        const contentStr = fingerprintData.toString().toLowerCase();
                        if (contentStr.includes('lie') || contentStr.includes('trash') || contentStr.includes('blocked')) {
                            privacy = 'high_privacy';
                        }
                        
                        console.log("🔍 FiFi Fingerprinting (CreepJS) complete:", {
                            fingerprint_id: fingerprintId, 
                            method: 'creepjs', 
                            privacy: privacy, 
                            working_methods: workingMethods.length,
                            components: workingMethods.slice(0, 5), // Log first 5 for debugging
                            data_length: fingerprintData.toString().length
                        });
                        
                        redirectWithFingerprint(sessionId, fingerprintId, 'creepjs', privacy, workingMethods);
                        return;
                    }
                    
                    // If max attempts reached, use fallback
                    if (attempts >= maxAttempts) {
                        clearInterval(checkCreepCompletion);
                        console.warn('🕒 CreepJS completion timeout, using fallback');
                        handleFallback(sessionId, 'creepjs_timeout');
                    }
                    
                } catch (checkError) {
                    console.warn('🚨 Error checking CreepJS completion:', checkError);
                    if (attempts >= maxAttempts) {
                        clearInterval(checkCreepCompletion);
                        handleFallback(sessionId, 'creepjs_check_error');
                    }
                }
            }, 500); // Check every 500ms
        };
        
        script.onerror = function() {
            console.error('🚨 Failed to load CreepJS library');
            handleFallback(sessionId, 'creepjs_load_failed');
        };
        
        // Add script to document
        document.head.appendChild(script);
        
        // Global timeout fallback
        setTimeout(function() {
            if (!window.fifi_fp_completed) {
                console.warn('🕒 Global CreepJS timeout, using fallback');
                handleFallback(sessionId, 'creepjs_global_timeout');
            }
        }, 30000); // 30 second global timeout
        
    } catch (error) {
        console.error("🚨 FiFi Fingerprinting component caught a critical error:", error);
        handleFallback(sessionId, 'critical_error');
    }
    
    // Helper function to create a simple hash
    function hashString(str) {
        let hash = 0;
        if (str.length === 0) return hash.toString(36);
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // Convert to 32-bit integer
        }
        return Math.abs(hash).toString(36);
    }
    
    // Helper function to handle fallback fingerprinting
    function handleFallback(sessionId, reason) {
        if (window.fifi_fp_completed) return; // Prevent double execution
        
        console.log('🔄 Using fallback fingerprinting due to:', reason);
        
        // Generate fallback fingerprint using basic browser data
        const fallbackComponents = [];
        const workingMethods = ['fallback'];
        
        try {
            // Collect basic browser information
            fallbackComponents.push(navigator.userAgent || 'unknown');
            fallbackComponents.push(screen.width + 'x' + screen.height + 'x' + screen.colorDepth);
            fallbackComponents.push(navigator.language || 'unknown');
            fallbackComponents.push(navigator.languages ? navigator.languages.join(',') : 'unknown');
            fallbackComponents.push(Intl.DateTimeFormat().resolvedOptions().timeZone || 'unknown');
            fallbackComponents.push(navigator.platform || 'unknown');
            fallbackComponents.push(navigator.hardwareConcurrency || 'unknown');
            fallbackComponents.push(navigator.deviceMemory || 'unknown');
            fallbackComponents.push(window.innerWidth + 'x' + window.innerHeight);
            
            // Add canvas fingerprint if available
            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                ctx.textBaseline = 'top';
                ctx.font = '14px Arial';
                ctx.fillStyle = '#f60';
                ctx.fillRect(125, 1, 62, 20);
                ctx.fillStyle = '#069';
                ctx.fillText('FiFi fingerprint 🔍', 2, 15);
                ctx.fillStyle = 'rgba(102, 204, 0, 0.7)';
                ctx.fillText('FiFi fingerprint 🔍', 4, 17);
                const canvasData = canvas.toDataURL();
                fallbackComponents.push(canvasData.substring(canvasData.length - 100)); // Last 100 chars
                workingMethods.push('canvas');
            } catch (e) {
                console.warn('Canvas fingerprinting failed:', e.message);
                workingMethods.push('canvas_blocked');
            }
            
            // Try WebGL fingerprint
            try {
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                if (gl) {
                    const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                    const vendor = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);
                    const renderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
                    fallbackComponents.push(vendor + '|' + renderer);
                    workingMethods.push('webgl');
                }
            } catch (e) {
                console.warn('WebGL fingerprinting failed:', e.message);
                workingMethods.push('webgl_blocked');
            }
            
            // Try audio context fingerprint
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const analyser = audioContext.createAnalyser();
                const gainNode = audioContext.createGain();
                oscillator.connect(analyser);
                analyser.connect(gainNode);
                gainNode.connect(audioContext.destination);
                oscillator.frequency.value = 10000;
                oscillator.start();
                const freqData = new Uint8Array(analyser.frequencyBinCount);
                analyser.getByteFrequencyData(freqData);
                const audioFingerprint = Array.from(freqData.slice(0, 10)).join(',');
                fallbackComponents.push(audioFingerprint);
                workingMethods.push('audio');
                oscillator.stop();
                audioContext.close();
            } catch (e) {
                console.warn('Audio fingerprinting failed:', e.message);
                workingMethods.push('audio_blocked');
            }
            
            const combinedFallback = fallbackComponents.join('|');
            const fingerprintId = 'fallback_' + hashString(combinedFallback);
            const method = 'fallback';
            
            // Determine privacy level based on what worked
            let privacy = 'standard';
            const blockedMethods = workingMethods.filter(m => m.includes('blocked')).length;
            if (blockedMethods > 2) {
                privacy = 'high_privacy';
            } else if (blockedMethods > 0) {
                privacy = 'medium_privacy';
            }
            
            console.log("🔍 FiFi Fingerprinting (Fallback) complete:", {
                fingerprint_id: fingerprintId, 
                method: method, 
                privacy: privacy, 
                reason: reason,
                working_methods: workingMethods.length,
                blocked_methods: blockedMethods,
                components: workingMethods
            });
            
            redirectWithFingerprint(sessionId, fingerprintId, method, privacy, workingMethods);
            
        } catch (fallbackError) {
            console.error('🚨 Even fallback fingerprinting failed:', fallbackError);
            
            // Emergency fallback
            const emergencyId = 'emergency_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            redirectWithFingerprint(sessionId, emergencyId, 'emergency', 'high_privacy', ['emergency']);
        }
    }
    
    // Helper function to redirect with fingerprint data
    function redirectWithFingerprint(sessionId, fingerprintId, method, privacy, workingMethods) {
        if (window.fifi_fp_completed) return; // Prevent double execution
        window.fifi_fp_completed = true;
        
        function getAppUrl() {
            try {
                if (window.parent && window.parent.location.origin === window.location.origin) {
                    return window.parent.location.origin + window.parent.location.pathname;
                }
            } catch (e) {
                console.warn("Using current window location as fallback");
            }
            return window.location.origin + window.location.pathname;
        }
        
        const appUrl = getAppUrl();
        const methodsString = Array.isArray(workingMethods) ? workingMethods.join(',') : String(workingMethods);
        const fingerprintUrl = `${appUrl}?event=fingerprint_complete&session_id=${sessionId}&fingerprint_id=${encodeURIComponent(fingerprintId)}&method=${encodeURIComponent(method)}&privacy=${encodeURIComponent(privacy)}&working_methods=${encodeURIComponent(methodsString)}&timestamp=${Date.now()}`;
        
        console.log("🔍 FiFi Fingerprinting: Redirecting with data...");
        
        try {
            if (window.parent && window.parent.location.origin === window.location.origin) {
                window.parent.location.href = fingerprintUrl;
            } else {
                window.location.href = fingerprintUrl;
            }
        } catch (e) {
            console.error('❌ Fingerprint redirect failed:', e);
            
            // Last resort: try reload
            try {
                if (window.parent && window.parent !== window) {
                    window.parent.location.reload();
                } else {
                    window.location.reload();
                }
            } catch (reloadError) {
                console.error('💥 CATASTROPHIC: Even reload failed. Manual intervention required.', reloadError);
            }
        }
    }
    
})();
</script>
</body>
</html>
